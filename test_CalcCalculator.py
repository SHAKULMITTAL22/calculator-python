# ********RoostGPT********
"""
Test generated by RoostGPT for test Python-test using AI Type Open AI and AI Model gpt-4o

ROOST_METHOD_HASH=calculator_9ebd2df6b3
ROOST_METHOD_SIG_HASH=calculator_ad84dc0779

### Scenario 1: Addition of Two Positive Numbers
Details:
  TestName: test_addition_of_two_positive_numbers
  Description: Verify that the calculator correctly handles the addition of two positive numbers.
Execution:
  Arrange: Set num1 to 5, num2 to 7, and operation to '+'.
  Act: Call the `calculator` function with these parameters.
  Assert: Check that the result is 12.
Validation:
  This test ensures that the calculator correctly implements the addition operation, a fundamental requirement for its functionality.

### Scenario 2: Subtraction of Two Positive Numbers
Details:
  TestName: test_subtraction_of_two_positive_numbers
  Description: Verify that the calculator correctly handles the subtraction of two positive numbers.
Execution:
  Arrange: Set num1 to 10, num2 to 3, and operation to '-'.
  Act: Call the `calculator` function with these parameters.
  Assert: Check that the result is 7.
Validation:
  This test confirms that the calculator can correctly perform subtraction, which is essential for basic arithmetic operations.

### Scenario 3: Multiplication of Two Positive Numbers
Details:
  TestName: test_multiplication_of_two_positive_numbers
  Description: Verify that the calculator correctly handles the multiplication of two positive numbers.
Execution:
  Arrange: Set num1 to 4, num2 to 6, and operation to '*'.
  Act: Call the `calculator` function with these parameters.
  Assert: Check that the result is 24.
Validation:
  This test ensures that the calculator can accurately perform multiplication, a key arithmetic operation.

### Scenario 4: Division of Two Positive Numbers
Details:
  TestName: test_division_of_two_positive_numbers
  Description: Verify that the calculator correctly handles the division of two positive numbers.
Execution:
  Arrange: Set num1 to 8, num2 to 2, and operation to '/'.
  Act: Call the `calculator` function with these parameters.
  Assert: Check that the result is 4.0.
Validation:
  This test confirms that the calculator can correctly perform division, a critical arithmetic function.

### Scenario 5: Division by Zero
Details:
  TestName: test_division_by_zero
  Description: Verify that the calculator handles division by zero appropriately.
Execution:
  Arrange: Set num1 to 8, num2 to 0, and operation to '/'.
  Act: Call the `calculator` function with these parameters.
  Assert: Check that the result is "Cannot divide by zero".
Validation:
  This test ensures that the calculator correctly handles division by zero, preventing runtime errors and ensuring robustness.

### Scenario 6: Invalid Operation
Details:
  TestName: test_invalid_operation
  Description: Verify that the calculator returns an appropriate message for an invalid operation.
Execution:
  Arrange: Set num1 to 8, num2 to 2, and operation to '%'.
  Act: Call the `calculator` function with these parameters.
  Assert: Check that the result is "Invalid operation".
Validation:
  This test checks that the calculator can handle invalid operations gracefully, maintaining user experience and application stability.

### Scenario 7: Addition of Negative Numbers
Details:
  TestName: test_addition_of_negative_numbers
  Description: Verify that the calculator correctly handles the addition of two negative numbers.
Execution:
  Arrange: Set num1 to -5, num2 to -3, and operation to '+'.
  Act: Call the `calculator` function with these parameters.
  Assert: Check that the result is -8.
Validation:
  This test ensures that the calculator can correctly handle the addition of negative numbers, which is essential for comprehensive arithmetic operations.

### Scenario 8: Subtraction Resulting in Negative Number
Details:
  TestName: test_subtraction_resulting_in_negative_number
  Description: Verify that the calculator correctly handles subtraction that results in a negative number.
Execution:
  Arrange: Set num1 to 3, num2 to 10, and operation to '-'.
  Act: Call the `calculator` function with these parameters.
  Assert: Check that the result is -7.
Validation:
  This test confirms that the calculator can handle cases where subtraction results in a negative number, ensuring accurate arithmetic operations.

### Scenario 9: Multiplication by Zero
Details:
  TestName: test_multiplication_by_zero
  Description: Verify that the calculator correctly handles multiplication by zero.
Execution:
  Arrange: Set num1 to 5, num2 to 0, and operation to '*'.
  Act: Call the `calculator` function with these parameters.
  Assert: Check that the result is 0.
Validation:
  This test ensures that the calculator correctly implements the multiplication by zero rule, a fundamental arithmetic principle.

### Scenario 10: Division of Negative Numbers
Details:
  TestName: test_division_of_negative_numbers
  Description: Verify that the calculator correctly handles the division of two negative numbers.
Execution:
  Arrange: Set num1 to -10, num2 to -2, and operation to '/'.
  Act: Call the `calculator` function with these parameters.
  Assert: Check that the result is 5.0.
Validation:
  This test confirms that the calculator can handle the division of negative numbers, ensuring comprehensive arithmetic functionality.
"""

# ********RoostGPT********
import pytest
from calc import calculator

class Test_CalcCalculator:

    @pytest.mark.smoke
    @pytest.mark.positive
    def test_addition_of_two_positive_numbers(self):
        # Arrange
        num1 = 5
        num2 = 7
        operation = '+'
        
        # Act
        result = calculator(num1, num2, operation)
        
        # Assert
        assert result == 12, f"Expected 12 but got {result}"

    @pytest.mark.regression
    @pytest.mark.positive
    def test_subtraction_of_two_positive_numbers(self):
        # Arrange
        num1 = 10
        num2 = 3
        operation = '-'
        
        # Act
        result = calculator(num1, num2, operation)
        
        # Assert
        assert result == 7, f"Expected 7 but got {result}"

    @pytest.mark.regression
    @pytest.mark.positive
    def test_multiplication_of_two_positive_numbers(self):
        # Arrange
        num1 = 4
        num2 = 6
        operation = '*'
        
        # Act
        result = calculator(num1, num2, operation)
        
        # Assert
        assert result == 24, f"Expected 24 but got {result}"

    @pytest.mark.regression
    @pytest.mark.positive
    def test_division_of_two_positive_numbers(self):
        # Arrange
        num1 = 8
        num2 = 2
        operation = '/'
        
        # Act
        result = calculator(num1, num2, operation)
        
        # Assert
        assert result == 4.0, f"Expected 4.0 but got {result}"

    @pytest.mark.security
    @pytest.mark.invalid
    def test_division_by_zero(self):
        # Arrange
        num1 = 8
        num2 = 0
        operation = '/'
        
        # Act
        result = calculator(num1, num2, operation)
        
        # Assert
        assert result == "Cannot divide by zero", f"Expected 'Cannot divide by zero' but got {result}"

    @pytest.mark.security
    @pytest.mark.invalid
    def test_invalid_operation(self):
        # Arrange
        num1 = 8
        num2 = 2
        operation = '%'
        
        # Act
        result = calculator(num1, num2, operation)
        
        # Assert
        assert result == "Invalid operation", f"Expected 'Invalid operation' but got {result}"

    @pytest.mark.regression
    @pytest.mark.positive
    def test_addition_of_negative_numbers(self):
        # Arrange
        num1 = -5
        num2 = -3
        operation = '+'
        
        # Act
        result = calculator(num1, num2, operation)
        
        # Assert
        assert result == -8, f"Expected -8 but got {result}"

    @pytest.mark.regression
    @pytest.mark.positive
    def test_subtraction_resulting_in_negative_number(self):
        # Arrange
        num1 = 3
        num2 = 10
        operation = '-'
        
        # Act
        result = calculator(num1, num2, operation)
        
        # Assert
        assert result == -7, f"Expected -7 but got {result}"

    @pytest.mark.regression
    @pytest.mark.positive
    def test_multiplication_by_zero(self):
        # Arrange
        num1 = 5
        num2 = 0
        operation = '*'
        
        # Act
        result = calculator(num1, num2, operation)
        
        # Assert
        assert result == 0, f"Expected 0 but got {result}"

    @pytest.mark.regression
    @pytest.mark.positive
    def test_division_of_negative_numbers(self):
        # Arrange
        num1 = -10
        num2 = -2
        operation = '/'
        
        # Act
        result = calculator(num1, num2, operation)
        
        # Assert
        assert result == 5.0, f"Expected 5.0 but got {result}"
